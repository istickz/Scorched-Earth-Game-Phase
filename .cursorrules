# Phaser 3 + TypeScript Game Development Rules

## Technology Stack
- **Phaser 3** (latest stable version) - main game engine
- **TypeScript** with strict mode enabled
- **Matter.js** physics (integrated in Phaser)
- **Vite** as build tool and dev server
- **WebRTC** for P2P multiplayer (no backend server)

## Code Style & Architecture

### General Principles
1. Write strongly-typed TypeScript code
2. Use ES modules for all imports
3. Follow SOLID principles
4. Separate concerns: rendering ≠ game logic ≠ network sync
5. Prefer composition over inheritance
6. Use dependency injection where appropriate

### Naming Conventions
- Classes: PascalCase (e.g., `GameScene`, `TankEntity`)
- Files: PascalCase for classes (e.g., `GameScene.ts`)
- Variables/functions: camelCase (e.g., `calculateTrajectory`)
- Constants: UPPER_SNAKE_CASE (e.g., `MAX_POWER`)
- Interfaces: prefix with `I` (e.g., `ITankConfig`)
- Types: PascalCase with `Type` suffix (e.g., `ProjectileType`)

### Project Structure
```
src/
├── scenes/          # Phaser scenes only
├── entities/        # Game objects (Tank, Projectile, etc.)
├── systems/         # Game systems (AI, Explosions, etc.)
├── network/         # WebRTC and multiplayer logic
├── utils/           # Helper functions
├── types/           # TypeScript type definitions
├── config/          # Configuration files
└── assets/          # Images, sounds, etc.
```

## Phaser-Specific Rules

### Scene Management
- Use Phaser's Scene lifecycle: `init()`, `preload()`, `create()`, `update()`
- Never call `update()` manually - let Phaser handle it
- Use Scene data manager for storing state: `this.registry.set()`
- Communicate between scenes using events: `this.events.emit()`

### Coordinate System
- Remember: Phaser's Y-axis points DOWN (screen space)
- Angles: use degrees (0° = right, clockwise rotation)
- Always set proper origins with `setOrigin(x, y)` for rotation pivots
- Default origin is (0.5, 0.5) - center of sprite

### Physics (Matter.js)
- Access via `this.matter` in scenes
- Set physics body origins correctly: `setBody({ ... }, { shape: ... })`
- Use `setFixedRotation()` for tanks if needed
- Enable debug rendering during development: `debug: true`

### Game Objects
- Prefer `Phaser.GameObjects.Container` for composite objects (tank + turret)
- Use `Phaser.GameObjects.Graphics` for dynamic terrain drawing
- Set proper depth/z-index with `setDepth()`
- Clean up objects with `destroy()` when no longer needed

### Particles & Effects
- Use `this.add.particles()` for particle emitters
- Configure particles in create(), trigger in update()
- Set emitter lifespan and frequency appropriately
- Use particle zones for complex emission shapes

### Sound System
- Load all sounds in BootScene's `preload()`
- Access via `this.sound.add('key')`
- Use sound sprites for multiple sound effects in one file
- Set global volume in game config

### Animations & Tweens
- Use `this.tweens.add()` for smooth interpolations
- Chain tweens with `onComplete` callbacks
- Use `this.time.delayedCall()` for timed events
- Avoid `setInterval/setTimeout` - use Phaser's timer events

## TypeScript Rules

### Type Safety
- Enable `strict: true` in tsconfig.json
- **NEVER use `any` type** - always specify proper types or use `unknown`
- Define interfaces for all data structures
- **NEVER use `enum`** - use const objects with type aliases instead (see example below)
- Type all function parameters and return values
- Prefix unused parameters with `_` (e.g., `_unusedParam: number`)
- Remove unused imports immediately

### Enums Alternative (IMPORTANT!)
Since project uses `erasableSyntaxOnly`, enums are NOT allowed. Use this pattern:
```typescript
// ✅ CORRECT - const object + type alias
export const WeaponType = {
  STANDARD: 'standard',
  SALVO: 'salvo',
  HAZELNUT: 'hazelnut'
} as const;

export type WeaponType = typeof WeaponType[keyof typeof WeaponType];

// ❌ WRONG - enum not supported
export enum WeaponType {
  STANDARD = 'standard'
}
```

### Proper Type Usage
```typescript
// ❌ WRONG - using any
function fireSalvo(config: any) { ... }

// ✅ CORRECT - specific type
function fireSalvo(config: { salvoCount?: number; salvoSpread?: number }) { ... }

// ❌ WRONG - unused parameter causing warning
onTurnChanged: (newIndex: number) => { ... } // newIndex not used

// ✅ CORRECT - prefix with underscore
onTurnChanged: (_newIndex: number) => { ... }
```

### Factory Methods & Type Casting
When calling factory methods (e.g., `ShieldFactory.getShield()`, `WeaponFactory.getWeapon()`), always use proper types instead of `any`:
```typescript
// ❌ WRONG - using any for type casting
const shield = ShieldFactory.getShield(weapon as any);

// ✅ CORRECT - use proper type (import ShieldType from @/types/shields)
import { ShieldType } from '@/types/shields';
const shield = ShieldFactory.getShield(weapon as ShieldType);

// ❌ WRONG - using any for weapon factory
const weapon = WeaponFactory.getWeapon(weaponType as any);

// ✅ CORRECT - use proper type (import WeaponType from @/types/weapons)
import { WeaponType } from '@/types/weapons';
const weapon = WeaponFactory.getWeapon(weaponType as WeaponType);
```

### Phaser Types
```typescript
// Always type scene references
class MyScene extends Phaser.Scene {
  private player!: Phaser.GameObjects.Sprite;
  private matter!: Phaser.Physics.Matter.MatterPhysics;
}

// Type event callbacks
this.events.on('eventName', (data: MyDataType) => { ... });
```

### Graphics Positioning (CRITICAL!)
When using `Phaser.GameObjects.Graphics`, ALWAYS set position first:
```typescript
// ❌ WRONG - draws at wrong position
const graphics = this.scene.add.graphics();
graphics.fillCircle(x, y, radius); // Wrong!

// ✅ CORRECT - set position, then draw at (0,0)
const graphics = this.scene.add.graphics();
graphics.setPosition(x, y); // Position first!
graphics.fillCircle(0, 0, radius); // Draw at origin
```

## WebRTC & Multiplayer

### Architecture
- WebRTC is used ONLY for data channels (no media streams)
- Use manual signaling via copy/paste UI (no signaling server)
- STUN server: `stun:stun.l.google.com:19302`
- Sync only player inputs, not full game state
- Physics must be deterministic on both clients

### Network Messages
- Keep messages small (JSON, < 1KB)
- Use typed message interfaces
- Include message type/version in every packet
- Handle disconnections gracefully
- Implement simple lag compensation if needed

## Performance Best Practices
- Pool frequently created/destroyed objects
- Use texture atlases instead of individual images
- Limit particle count (< 500 active at once)
- Use `setVisible(false)` instead of destroying/recreating
- Profile with browser DevTools when optimizing

## Common Pitfalls to Avoid

### TypeScript
- ❌ **NEVER use `enum`** - use const objects (causes build errors with erasableSyntaxOnly)
- ❌ **NEVER use `any`** - always specify proper types
- ❌ Don't use `any` when calling factory methods - import and use proper types (e.g., `ShieldType`, `WeaponType`)
- ❌ Don't leave unused imports or parameters (causes linter warnings)
- ❌ Don't add trailing commas in const objects meant to be enums
- ✅ Prefix unused parameters with `_` to indicate intentional non-use
- ✅ Import proper types from `@/types/*` when working with factories

### Phaser Graphics
- ❌ Don't draw at absolute coordinates in Graphics (causes random visuals)
- ✅ Always `setPosition()` first, then draw at (0,0)
- ❌ Don't use `undefined as any` in destroy methods (unnecessary)
- ✅ Just call `destroy()` and let TypeScript handle cleanup

### Phaser General
- ❌ Don't use browser localStorage/sessionStorage (use Phaser's data manager)
- ❌ Don't manipulate DOM directly (use Phaser's UI system)
- ❌ Don't mix radians and degrees (Phaser uses degrees)
- ❌ Don't forget to remove event listeners in `shutdown()`
- ❌ Don't use arrow functions for scene methods (loses `this` context)
- ❌ Don't create new objects in `update()` loop (causes garbage collection)

### BitmapText
- ❌ Don't use `setTint()` on BitmapText (doesn't work)
- ✅ Use `setTintFill()` for BitmapText color changes
- ❌ Don't use Unicode characters (arrows, etc) in bitmap fonts
- ✅ Use ASCII alternatives: `<>` for arrows, `LEFT/RIGHT` for directions

## Error Handling
- Wrap WebRTC operations in try-catch blocks
- Validate all network messages before processing
- Show user-friendly error messages for network failures
- Log errors to console with context information
- Gracefully degrade features if optional dependencies fail

## Testing Considerations
- Write unit tests for game logic (separate from Phaser)
- Test bot AI algorithms independently
- Test WebRTC connection flow manually
- Profile physics performance with many objects
- Test on different screen sizes/resolutions

## When Generating Code
1. Always include TypeScript types
2. Add JSDoc comments for public methods
3. Follow the project structure defined above
4. Use Phaser's built-in features before custom implementations
5. Write modular, reusable code
6. Consider performance implications
7. Handle edge cases and errors
8. Suggest improvements proactively

## Pre-Commit Checklist
Before considering code complete, verify:
1. ✅ No `any` types used
2. ✅ No `enum` declarations (use const objects instead)
3. ✅ No unused imports or variables
4. ✅ Unused parameters prefixed with `_`
5. ✅ Graphics use `setPosition()` before drawing
6. ✅ BitmapText uses `setTintFill()` not `setTint()`
7. ✅ No Unicode characters in bitmap font strings
8. ✅ All `destroy()` methods clean without `as any`
9. ✅ Run `npm run lint` - no warnings
10. ✅ Run `npm run build` - compiles successfully

## Design Patterns

### When to Use Inheritance vs Composition
- **Inheritance**: Use for families of related objects with shared behavior (e.g., Weapon base class with StandardWeapon, SalvoWeapon subclasses)
- **Composition**: Use for combining independent behaviors (e.g., Tank contains multiple systems)
- **Rule**: If objects share a common interface and behavior structure, inheritance is appropriate

### Common Patterns in This Project
- **Strategy Pattern**: Different weapon firing strategies (StandardWeapon, SalvoWeapon, HazelnutWeapon)
- **Template Method**: Base Weapon class defines structure, subclasses implement specifics
- **Factory Pattern**: WeaponFactory creates weapon instances by type
- **Component Pattern**: Systems (TrajectorySystem, ExplosionSystem) handle specific concerns

### Weapon System Architecture
- **Weapon Classes**: Handle weapon-specific logic and data (firing plans, splitting logic)
- **GameScene**: Manages Projectile lifecycle (creation, tracking, destruction)
- **TrajectorySystem**: Handles trajectory visualization using weapon physics parameters
- **Separation**: Weapon generates fire plans (IFirePlan), GameScene executes them

## When You're Unsure
- Ask clarifying questions before implementing
- Propose multiple solutions with trade-offs
- Refer to Phaser 3 documentation
- Consider TypeScript best practices
- Think about multiplayer synchronization implications